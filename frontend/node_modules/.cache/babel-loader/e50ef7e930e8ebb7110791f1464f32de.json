{"ast":null,"code":"import React,{createContext,useContext,useRef,useState}from'react';export const EqContext=createContext();export function useEq(){return useContext(EqContext);}export function EqProvider(_ref){let{children}=_ref;const mathFieldRef=useRef(null);const[eq,setEq]=useState(\"\");const tokens=new Set([\"{}={}\",\"{}\\\\gt{}\",\"{}\\\\ge{}\",\"{}\\\\lt{}\",\"{}\\\\le{}\",\"{}+{}\",\"{}-{}\",\"{}\\\\cdot{}\",\"{}\\\\div{}\",\"{}^{}\",\"{}_{}\",\"{}\\\\to{}\",\"\\\\frac{}{}\",\"\\\\frac{d}{d{}}{}\",\"\\\\partial{}\",\"\\\\lim_{}{}\",\"\\\\sqrt{}\",\"\\\\sqrt[{}]{}\",\"\\\\log{}\",\"\\\\log_{}{}\",\"\\\\binom{}{}\",\"\\\\sum_{}^{}{}\",\"\\\\prod_{}^{}{}\",\"\\\\int_{}^{}{}\",\"\\\\oint_{}^{}{}\",\"\\\\left({}\\\\right)\",\"\\\\left[{}\\\\right]\",\"\\\\left|{}\\\\right|\",\"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\",\"\\\\left\\\\lceil{}\\\\right\\\\rceil\"]);function splitBranches(tree){for(var _len=arguments.length,operators=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){operators[_key-1]=arguments[_key];}const operator=operators[0];let new_tree;let tree_flag;let len;let prev;let char;let new_branch;let branch;for(let branch_index=tree.length-1;branch>=0;branch--){branch=tree[branch_index];if(typeof branch===\"string\"){new_tree=[];tree_flag=false;len=branch.length;prev=len;for(let i=len-1;i>=0;i--){char=branch[i];if(operators.includes(char)){new_branch.push(char,[],branch.slice(i+1,prev));new_branch=new_branch[1];prev=i;tree_flag=true;}}if(tree_flag){tree[branch_index]=new_tree;}}else{tree[branch_index]=splitBranches(branch);}}const expr=tree[0];const operands=[];let operand_index=tree.length-1;new_tree=[];tree_flag=false;len=expr.length;prev=len;for(let i=len-1;i>=0;i--){char=expr[i];if(operators.includes(char)&&(i>len-5||expr.slice(i+1,i+5)!=\"{}{}\")){tree_flag=true;new_tree.push(char,[],operands?[expr.slice(i+1,prev),...operands]:expr.slice(i+1,prev));new_tree=new_tree[1];prev=i;operands=[];}else if(char===\"{\"){operands.unshift(tree[operand_index]);operand_index--;}}return tree_flag?new_tree:tree;}// function generateTree() {\n//   const brace_stack = [], tree = [];\n//   let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n//   for (let i = 0; i < eq.length; i++) {\n//     switch (eq[i]) {\n//       case \"{\":\n//         brace_stack[brace_stack.length - 1].push(i+1);\n//         brace_stack.push([i + 1]);\n//       case \"}\":\n//         expr = \"\";\n//         brace_pairs = brace_stack.pop();\n//         brace_pairs.push(i);\n//         len = brace_pairs.length;\n//         operands = len > 2;\n//         for (let j = 0; j < len; j+=2) {\n//           expr += eq.slice(brace_pairs[j], brace_pairs[j+1]);\n//         }\n//         if (operands) {\n//           tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n//         } else {\n//           if (!isNaN(expr)) {\n//             expr = +expr;\n//           }\n//           tree.push(expr);\n//         }\n//         brace_stack[brace_stack.length - 1].push(i);\n//     }\n//   }\n//   tree = splitBranches(tree, \"+\", \"-\");\n//   tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n//   tree = splitBranches(tree, \"^\");\n//   return tree;\n// }\nfunction writeLatex(latex){var _mathFieldRef$current;let isCmd=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let lcount=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const mathField=mathFieldRef===null||mathFieldRef===void 0?void 0:(_mathFieldRef$current=mathFieldRef.current)===null||_mathFieldRef$current===void 0?void 0:_mathFieldRef$current.mathField;if(mathField){if(isCmd){mathField.cmd(latex);}else{mathField.typedText(latex);}mathField.keystoke(\"Left \".repeat(lcount));setEq(mathField.latex());}}return/*#__PURE__*/React.createElement(EqContext.Provider,{value:{mathFieldRef,writeLatex,eq,setEq}},children);}","map":{"version":3,"names":["React","createContext","useContext","useRef","useState","EqContext","useEq","EqProvider","_ref","children","mathFieldRef","eq","setEq","tokens","Set","splitBranches","tree","_len","arguments","length","operators","Array","_key","operator","new_tree","tree_flag","len","prev","char","new_branch","branch","branch_index","i","includes","push","slice","expr","operands","operand_index","unshift","writeLatex","latex","_mathFieldRef$current","isCmd","undefined","lcount","mathField","current","cmd","typedText","keystoke","repeat","createElement","Provider","value"],"sources":["/Users/kirillrybkov/Desktop/diff-eq-visualiser/frontend/src/components/EqContext.js"],"sourcesContent":["import React, { createContext, useContext, useRef, useState } from 'react';\n\nexport const EqContext = createContext();\n\nexport function useEq() {\n  return useContext(EqContext);\n}\n\nexport function EqProvider({ children }) {\n  const mathFieldRef = useRef(null);\n  const [eq, setEq] = useState(\"\");\n\n  const tokens = new Set([\n    \"{}={}\", \"{}\\\\gt{}\", \"{}\\\\ge{}\", \"{}\\\\lt{}\", \"{}\\\\le{}\",\n    \"{}+{}\", \"{}-{}\", \"{}\\\\cdot{}\", \"{}\\\\div{}\", \"{}^{}\", \"{}_{}\", \"{}\\\\to{}\",\n    \"\\\\frac{}{}\", \"\\\\frac{d}{d{}}{}\", \"\\\\partial{}\", \"\\\\lim_{}{}\",\n    \"\\\\sqrt{}\", \"\\\\sqrt[{}]{}\", \"\\\\log{}\", \"\\\\log_{}{}\", \"\\\\binom{}{}\",\n    \"\\\\sum_{}^{}{}\", \"\\\\prod_{}^{}{}\", \"\\\\int_{}^{}{}\", \"\\\\oint_{}^{}{}\",\n    \"\\\\left({}\\\\right)\", \"\\\\left[{}\\\\right]\", \"\\\\left|{}\\\\right|\",\n    \"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\", \"\\\\left\\\\lceil{}\\\\right\\\\rceil\"\n  ]);\n\n  function splitBranches(tree, ...operators) {\n    const operator = operators[0];\n    let new_tree\n    let tree_flag\n    let len\n    let prev\n    let char\n    let new_branch\n    let branch\n\n    for (let branch_index = tree.length - 1; branch >= 0; branch--) {\n      branch = tree[branch_index];\n      if (typeof branch === \"string\") {\n        new_tree = []\n        tree_flag = false\n        len = branch.length\n        prev = len;\n        for (let i = len - 1; i >= 0; i--) {\n          char = branch[i];\n          if (operators.includes(char)) {\n            new_branch.push(char, [], branch.slice(i + 1, prev));\n            new_branch = new_branch[1];\n            prev = i;\n            tree_flag = true;\n          }\n        }\n        if (tree_flag) {\n          tree[branch_index] = new_tree;\n        }\n      } else {\n        tree[branch_index] = splitBranches(branch);\n      }\n    }\n\n    const expr = tree[0]\n    const operands = [];\n    let operand_index = tree.length - 1;\n    new_tree = []\n    tree_flag = false\n    len = expr.length\n    prev = len;\n    for (let i = len - 1; i >= 0; i--) {\n      char = expr[i];\n      if (operators.includes(char) && (i > len - 5 || expr.slice(i + 1, i + 5) != \"{}{}\")) {\n        tree_flag = true;\n        new_tree.push(char, [], (operands ? [expr.slice(i + 1, prev), ...operands] : expr.slice(i + 1, prev)));\n        new_tree = new_tree[1];\n        prev = i;\n        operands = [];\n      } else if (char === \"{\") {\n        operands.unshift(tree[operand_index]);\n        operand_index--;\n      }\n    }\n    return (tree_flag ? new_tree : tree)\n  }\n  \n  // function generateTree() {\n  //   const brace_stack = [], tree = [];\n  //   let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n\n  //   for (let i = 0; i < eq.length; i++) {\n  //     switch (eq[i]) {\n  //       case \"{\":\n  //         brace_stack[brace_stack.length - 1].push(i+1);\n  //         brace_stack.push([i + 1]);\n\n  //       case \"}\":\n  //         expr = \"\";\n  //         brace_pairs = brace_stack.pop();\n  //         brace_pairs.push(i);\n  //         len = brace_pairs.length;\n  //         operands = len > 2;\n  //         for (let j = 0; j < len; j+=2) {\n  //           expr += eq.slice(brace_pairs[j], brace_pairs[j+1]);\n  //         }\n\n  //         if (operands) {\n  //           tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n  //         } else {\n  //           if (!isNaN(expr)) {\n  //             expr = +expr;\n  //           }\n  //           tree.push(expr);\n  //         }\n  //         brace_stack[brace_stack.length - 1].push(i);\n  //     }\n  //   }\n    \n  //   tree = splitBranches(tree, \"+\", \"-\");\n  //   tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n  //   tree = splitBranches(tree, \"^\");\n  //   return tree;\n  // }\n\n  function writeLatex(latex, isCmd=false, lcount=0) {\n    const mathField = mathFieldRef?.current?.mathField; \n    if (mathField) {\n      if (isCmd) {\n        mathField.cmd(latex);\n      } else {\n        mathField.typedText(latex);\n      }\n      mathField.keystoke(\"Left \".repeat(lcount));\n      setEq(mathField.latex());\n    }\n  }\n\n  return (\n    <EqContext.Provider \n      value={{ \n        mathFieldRef,\n        writeLatex,\n        eq,\n        setEq\n      }}\n    >\n      {children}\n    </EqContext.Provider>\n  );\n}\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,UAAU,CAAEC,MAAM,CAAEC,QAAQ,KAAQ,OAAO,CAE1E,MAAO,MAAM,CAAAC,SAAS,CAAGJ,aAAa,CAAC,CAAC,CAExC,MAAO,SAAS,CAAAK,KAAKA,CAAA,CAAG,CACtB,MAAO,CAAAJ,UAAU,CAACG,SAAS,CAAC,CAC9B,CAEA,MAAO,SAAS,CAAAE,UAAUA,CAAAC,IAAA,CAAe,IAAd,CAAEC,QAAS,CAAC,CAAAD,IAAA,CACrC,KAAM,CAAAE,YAAY,CAAGP,MAAM,CAAC,IAAI,CAAC,CACjC,KAAM,CAACQ,EAAE,CAAEC,KAAK,CAAC,CAAGR,QAAQ,CAAC,EAAE,CAAC,CAEhC,KAAM,CAAAS,MAAM,CAAG,GAAI,CAAAC,GAAG,CAAC,CACrB,OAAO,CAAE,UAAU,CAAE,UAAU,CAAE,UAAU,CAAE,UAAU,CACvD,OAAO,CAAE,OAAO,CAAE,YAAY,CAAE,WAAW,CAAE,OAAO,CAAE,OAAO,CAAE,UAAU,CACzE,YAAY,CAAE,kBAAkB,CAAE,aAAa,CAAE,YAAY,CAC7D,UAAU,CAAE,cAAc,CAAE,SAAS,CAAE,YAAY,CAAE,aAAa,CAClE,eAAe,CAAE,gBAAgB,CAAE,eAAe,CAAE,gBAAgB,CACpE,mBAAmB,CAAE,mBAAmB,CAAE,mBAAmB,CAC7D,iCAAiC,CAAE,+BAA+B,CACnE,CAAC,CAEF,QAAS,CAAAC,aAAaA,CAACC,IAAI,CAAgB,SAAAC,IAAA,CAAAC,SAAA,CAAAC,MAAA,CAAXC,SAAS,KAAAC,KAAA,CAAAJ,IAAA,GAAAA,IAAA,MAAAK,IAAA,GAAAA,IAAA,CAAAL,IAAA,CAAAK,IAAA,IAATF,SAAS,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA,GACvC,KAAM,CAAAC,QAAQ,CAAGH,SAAS,CAAC,CAAC,CAAC,CAC7B,GAAI,CAAAI,QAAQ,CACZ,GAAI,CAAAC,SAAS,CACb,GAAI,CAAAC,GAAG,CACP,GAAI,CAAAC,IAAI,CACR,GAAI,CAAAC,IAAI,CACR,GAAI,CAAAC,UAAU,CACd,GAAI,CAAAC,MAAM,CAEV,IAAK,GAAI,CAAAC,YAAY,CAAGf,IAAI,CAACG,MAAM,CAAG,CAAC,CAAEW,MAAM,EAAI,CAAC,CAAEA,MAAM,EAAE,CAAE,CAC9DA,MAAM,CAAGd,IAAI,CAACe,YAAY,CAAC,CAC3B,GAAI,MAAO,CAAAD,MAAM,GAAK,QAAQ,CAAE,CAC9BN,QAAQ,CAAG,EAAE,CACbC,SAAS,CAAG,KAAK,CACjBC,GAAG,CAAGI,MAAM,CAACX,MAAM,CACnBQ,IAAI,CAAGD,GAAG,CACV,IAAK,GAAI,CAAAM,CAAC,CAAGN,GAAG,CAAG,CAAC,CAAEM,CAAC,EAAI,CAAC,CAAEA,CAAC,EAAE,CAAE,CACjCJ,IAAI,CAAGE,MAAM,CAACE,CAAC,CAAC,CAChB,GAAIZ,SAAS,CAACa,QAAQ,CAACL,IAAI,CAAC,CAAE,CAC5BC,UAAU,CAACK,IAAI,CAACN,IAAI,CAAE,EAAE,CAAEE,MAAM,CAACK,KAAK,CAACH,CAAC,CAAG,CAAC,CAAEL,IAAI,CAAC,CAAC,CACpDE,UAAU,CAAGA,UAAU,CAAC,CAAC,CAAC,CAC1BF,IAAI,CAAGK,CAAC,CACRP,SAAS,CAAG,IAAI,CAClB,CACF,CACA,GAAIA,SAAS,CAAE,CACbT,IAAI,CAACe,YAAY,CAAC,CAAGP,QAAQ,CAC/B,CACF,CAAC,IAAM,CACLR,IAAI,CAACe,YAAY,CAAC,CAAGhB,aAAa,CAACe,MAAM,CAAC,CAC5C,CACF,CAEA,KAAM,CAAAM,IAAI,CAAGpB,IAAI,CAAC,CAAC,CAAC,CACpB,KAAM,CAAAqB,QAAQ,CAAG,EAAE,CACnB,GAAI,CAAAC,aAAa,CAAGtB,IAAI,CAACG,MAAM,CAAG,CAAC,CACnCK,QAAQ,CAAG,EAAE,CACbC,SAAS,CAAG,KAAK,CACjBC,GAAG,CAAGU,IAAI,CAACjB,MAAM,CACjBQ,IAAI,CAAGD,GAAG,CACV,IAAK,GAAI,CAAAM,CAAC,CAAGN,GAAG,CAAG,CAAC,CAAEM,CAAC,EAAI,CAAC,CAAEA,CAAC,EAAE,CAAE,CACjCJ,IAAI,CAAGQ,IAAI,CAACJ,CAAC,CAAC,CACd,GAAIZ,SAAS,CAACa,QAAQ,CAACL,IAAI,CAAC,GAAKI,CAAC,CAAGN,GAAG,CAAG,CAAC,EAAIU,IAAI,CAACD,KAAK,CAACH,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG,CAAC,CAAC,EAAI,MAAM,CAAC,CAAE,CACnFP,SAAS,CAAG,IAAI,CAChBD,QAAQ,CAACU,IAAI,CAACN,IAAI,CAAE,EAAE,CAAGS,QAAQ,CAAG,CAACD,IAAI,CAACD,KAAK,CAACH,CAAC,CAAG,CAAC,CAAEL,IAAI,CAAC,CAAE,GAAGU,QAAQ,CAAC,CAAGD,IAAI,CAACD,KAAK,CAACH,CAAC,CAAG,CAAC,CAAEL,IAAI,CAAE,CAAC,CACtGH,QAAQ,CAAGA,QAAQ,CAAC,CAAC,CAAC,CACtBG,IAAI,CAAGK,CAAC,CACRK,QAAQ,CAAG,EAAE,CACf,CAAC,IAAM,IAAIT,IAAI,GAAK,GAAG,CAAE,CACvBS,QAAQ,CAACE,OAAO,CAACvB,IAAI,CAACsB,aAAa,CAAC,CAAC,CACrCA,aAAa,EAAE,CACjB,CACF,CACA,MAAQ,CAAAb,SAAS,CAAGD,QAAQ,CAAGR,IAAI,CACrC,CAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA,QAAS,CAAAwB,UAAUA,CAACC,KAAK,CAAyB,KAAAC,qBAAA,IAAvB,CAAAC,KAAK,CAAAzB,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAA0B,SAAA,CAAA1B,SAAA,IAAC,KAAK,IAAE,CAAA2B,MAAM,CAAA3B,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAA0B,SAAA,CAAA1B,SAAA,IAAC,CAAC,CAC9C,KAAM,CAAA4B,SAAS,CAAGpC,YAAY,SAAZA,YAAY,kBAAAgC,qBAAA,CAAZhC,YAAY,CAAEqC,OAAO,UAAAL,qBAAA,iBAArBA,qBAAA,CAAuBI,SAAS,CAClD,GAAIA,SAAS,CAAE,CACb,GAAIH,KAAK,CAAE,CACTG,SAAS,CAACE,GAAG,CAACP,KAAK,CAAC,CACtB,CAAC,IAAM,CACLK,SAAS,CAACG,SAAS,CAACR,KAAK,CAAC,CAC5B,CACAK,SAAS,CAACI,QAAQ,CAAC,OAAO,CAACC,MAAM,CAACN,MAAM,CAAC,CAAC,CAC1CjC,KAAK,CAACkC,SAAS,CAACL,KAAK,CAAC,CAAC,CAAC,CAC1B,CACF,CAEA,mBACEzC,KAAA,CAAAoD,aAAA,CAAC/C,SAAS,CAACgD,QAAQ,EACjBC,KAAK,CAAE,CACL5C,YAAY,CACZ8B,UAAU,CACV7B,EAAE,CACFC,KACF,CAAE,EAEDH,QACiB,CAAC,CAEzB","ignoreList":[]},"metadata":{},"sourceType":"module"}