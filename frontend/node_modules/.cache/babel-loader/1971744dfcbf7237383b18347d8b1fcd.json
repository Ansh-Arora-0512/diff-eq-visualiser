{"ast":null,"code":"var _jsxFileName = \"/Users/kirillrybkov/Desktop/diff-eq-visualiser/frontend/src/components/EqContext.js\";\nimport React, { createContext, useContext, useRef, useState } from 'react';\nexport const EqContext = createContext();\nexport function useEq() {\n  return useContext(EqContext);\n}\nexport function EqProvider({\n  children\n}) {\n  const mathFieldRef = useRef(null);\n  const [eq, setEq] = useState(\"\");\n  const tokens = new Set([\"{}={}\", \"{}\\\\gt{}\", \"{}\\\\ge{}\", \"{}\\\\lt{}\", \"{}\\\\le{}\", \"{}+{}\", \"{}-{}\", \"{}\\\\cdot{}\", \"{}\\\\div{}\", \"{}^{}\", \"{}_{}\", \"{}\\\\to{}\", \"\\\\frac{}{}\", \"\\\\frac{d}{d{}}{}\", \"\\\\partial{}\", \"\\\\lim_{}{}\", \"\\\\sqrt{}\", \"\\\\sqrt[{}]{}\", \"\\\\log{}\", \"\\\\log_{}{}\", \"\\\\binom{}{}\", \"\\\\sum_{}^{}{}\", \"\\\\prod_{}^{}{}\", \"\\\\int_{}^{}{}\", \"\\\\oint_{}^{}{}\", \"\\\\left({}\\\\right)\", \"\\\\left[{}\\\\right]\", \"\\\\left|{}\\\\right|\", \"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\", \"\\\\left\\\\lceil{}\\\\right\\\\rceil\"]);\n  function splitBranches(tree, ...operators) {\n    const operator = operators[0];\n    let new_tree;\n    let tree_flag;\n    let len;\n    let prev;\n    let char;\n    let new_branch;\n    let branch;\n    for (let branch_index = tree.length - 1; branch >= 0; branch--) {\n      branch = tree[branch_index];\n      if (typeof branch === \"string\") {\n        new_tree = [];\n        tree_flag = false;\n        len = branch.length;\n        prev = len;\n        for (let i = len - 1; i >= 0; i--) {\n          char = branch[i];\n          if (operators.includes(char)) {\n            new_branch.push(char, [], branch.slice(i + 1, prev));\n            new_branch = new_branch[1];\n            prev = i;\n            tree_flag = true;\n          }\n        }\n        if (tree_flag) {\n          tree[branch_index] = new_tree;\n        }\n      } else {\n        tree[branch_index] = splitBranches(branch);\n      }\n    }\n    const expr = tree[0];\n    const operands = [];\n    let operand_index = tree.length - 1;\n    new_tree = [];\n    tree_flag = false;\n    len = expr.length;\n    prev = len;\n    for (let i = len - 1; i >= 0; i--) {\n      char = expr[i];\n      if (operators.includes(char) && (i > len - 5 || expr.slice(i + 1, i + 5) != \"{}{}\")) {\n        tree_flag = true;\n        new_tree.push(char, [], operands ? [expr.slice(i + 1, prev), ...operands] : expr.slice(i + 1, prev));\n        new_tree = new_tree[1];\n        prev = i;\n        operands = [];\n      } else if (char === \"{\") {\n        operands.unshift(tree[operand_index]);\n        operand_index--;\n      }\n    }\n    return tree_flag ? new_tree : tree;\n  }\n\n  // function generateTree() {\n  //   const brace_stack = [], tree = [];\n  //   let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n\n  //   for (let i = 0; i < eq.length; i++) {\n  //     switch (eq[i]) {\n  //       case \"{\":\n  //         brace_stack[brace_stack.length - 1].push(i+1);\n  //         brace_stack.push([i + 1]);\n\n  //       case \"}\":\n  //         expr = \"\";\n  //         brace_pairs = brace_stack.pop();\n  //         brace_pairs.push(i);\n  //         len = brace_pairs.length;\n  //         operands = len > 2;\n  //         for (let j = 0; j < len; j+=2) {\n  //           expr += eq.slice(brace_pairs[j], brace_pairs[j+1]);\n  //         }\n\n  //         if (operands) {\n  //           tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n  //         } else {\n  //           if (!isNaN(expr)) {\n  //             expr = +expr;\n  //           }\n  //           tree.push(expr);\n  //         }\n  //         brace_stack[brace_stack.length - 1].push(i);\n  //     }\n  //   }\n\n  //   tree = splitBranches(tree, \"+\", \"-\");\n  //   tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n  //   tree = splitBranches(tree, \"^\");\n  //   return tree;\n  // }\n\n  function writeLatex(latex, isCmd = false, lcount = 0) {\n    var _mathFieldRef$current;\n    const mathField = mathFieldRef === null || mathFieldRef === void 0 ? void 0 : (_mathFieldRef$current = mathFieldRef.current) === null || _mathFieldRef$current === void 0 ? void 0 : _mathFieldRef$current.mathField;\n    if (mathField) {\n      if (isCmd) {\n        mathField.cmd(latex);\n      } else {\n        mathField.typedText(latex);\n      }\n      mathField.keystoke(\"Left \".repeat(lcount));\n      setEq(mathField.latex());\n    }\n  }\n  return /*#__PURE__*/React.createElement(EqContext.Provider, {\n    value: {\n      mathFieldRef,\n      writeLatex,\n      eq,\n      setEq\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 5\n    }\n  }, children);\n}","map":{"version":3,"names":["React","createContext","useContext","useRef","useState","EqContext","useEq","EqProvider","children","mathFieldRef","eq","setEq","tokens","Set","splitBranches","tree","operators","operator","new_tree","tree_flag","len","prev","char","new_branch","branch","branch_index","length","i","includes","push","slice","expr","operands","operand_index","unshift","writeLatex","latex","isCmd","lcount","_mathFieldRef$current","mathField","current","cmd","typedText","keystoke","repeat","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/kirillrybkov/Desktop/diff-eq-visualiser/frontend/src/components/EqContext.js"],"sourcesContent":["import React, { createContext, useContext, useRef, useState } from 'react';\n\nexport const EqContext = createContext();\n\nexport function useEq() {\n  return useContext(EqContext);\n}\n\nexport function EqProvider({ children }) {\n  const mathFieldRef = useRef(null);\n  const [eq, setEq] = useState(\"\");\n\n  const tokens = new Set([\n    \"{}={}\", \"{}\\\\gt{}\", \"{}\\\\ge{}\", \"{}\\\\lt{}\", \"{}\\\\le{}\",\n    \"{}+{}\", \"{}-{}\", \"{}\\\\cdot{}\", \"{}\\\\div{}\", \"{}^{}\", \"{}_{}\", \"{}\\\\to{}\",\n    \"\\\\frac{}{}\", \"\\\\frac{d}{d{}}{}\", \"\\\\partial{}\", \"\\\\lim_{}{}\",\n    \"\\\\sqrt{}\", \"\\\\sqrt[{}]{}\", \"\\\\log{}\", \"\\\\log_{}{}\", \"\\\\binom{}{}\",\n    \"\\\\sum_{}^{}{}\", \"\\\\prod_{}^{}{}\", \"\\\\int_{}^{}{}\", \"\\\\oint_{}^{}{}\",\n    \"\\\\left({}\\\\right)\", \"\\\\left[{}\\\\right]\", \"\\\\left|{}\\\\right|\",\n    \"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\", \"\\\\left\\\\lceil{}\\\\right\\\\rceil\"\n  ]);\n\n  function splitBranches(tree, ...operators) {\n    const operator = operators[0];\n    let new_tree\n    let tree_flag\n    let len\n    let prev\n    let char\n    let new_branch\n    let branch\n\n    for (let branch_index = tree.length - 1; branch >= 0; branch--) {\n      branch = tree[branch_index];\n      if (typeof branch === \"string\") {\n        new_tree = []\n        tree_flag = false\n        len = branch.length\n        prev = len;\n        for (let i = len - 1; i >= 0; i--) {\n          char = branch[i];\n          if (operators.includes(char)) {\n            new_branch.push(char, [], branch.slice(i + 1, prev));\n            new_branch = new_branch[1];\n            prev = i;\n            tree_flag = true;\n          }\n        }\n        if (tree_flag) {\n          tree[branch_index] = new_tree;\n        }\n      } else {\n        tree[branch_index] = splitBranches(branch);\n      }\n    }\n\n    const expr = tree[0]\n    const operands = [];\n    let operand_index = tree.length - 1;\n    new_tree = []\n    tree_flag = false\n    len = expr.length\n    prev = len;\n    for (let i = len - 1; i >= 0; i--) {\n      char = expr[i];\n      if (operators.includes(char) && (i > len - 5 || expr.slice(i + 1, i + 5) != \"{}{}\")) {\n        tree_flag = true;\n        new_tree.push(char, [], (operands ? [expr.slice(i + 1, prev), ...operands] : expr.slice(i + 1, prev)));\n        new_tree = new_tree[1];\n        prev = i;\n        operands = [];\n      } else if (char === \"{\") {\n        operands.unshift(tree[operand_index]);\n        operand_index--;\n      }\n    }\n    return (tree_flag ? new_tree : tree)\n  }\n  \n  // function generateTree() {\n  //   const brace_stack = [], tree = [];\n  //   let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n\n  //   for (let i = 0; i < eq.length; i++) {\n  //     switch (eq[i]) {\n  //       case \"{\":\n  //         brace_stack[brace_stack.length - 1].push(i+1);\n  //         brace_stack.push([i + 1]);\n\n  //       case \"}\":\n  //         expr = \"\";\n  //         brace_pairs = brace_stack.pop();\n  //         brace_pairs.push(i);\n  //         len = brace_pairs.length;\n  //         operands = len > 2;\n  //         for (let j = 0; j < len; j+=2) {\n  //           expr += eq.slice(brace_pairs[j], brace_pairs[j+1]);\n  //         }\n\n  //         if (operands) {\n  //           tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n  //         } else {\n  //           if (!isNaN(expr)) {\n  //             expr = +expr;\n  //           }\n  //           tree.push(expr);\n  //         }\n  //         brace_stack[brace_stack.length - 1].push(i);\n  //     }\n  //   }\n    \n  //   tree = splitBranches(tree, \"+\", \"-\");\n  //   tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n  //   tree = splitBranches(tree, \"^\");\n  //   return tree;\n  // }\n\n  function writeLatex(latex, isCmd=false, lcount=0) {\n    const mathField = mathFieldRef?.current?.mathField; \n    if (mathField) {\n      if (isCmd) {\n        mathField.cmd(latex);\n      } else {\n        mathField.typedText(latex);\n      }\n      mathField.keystoke(\"Left \".repeat(lcount));\n      setEq(mathField.latex());\n    }\n  }\n\n  return (\n    <EqContext.Provider \n      value={{ \n        mathFieldRef,\n        writeLatex,\n        eq,\n        setEq\n      }}\n    >\n      {children}\n    </EqContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}