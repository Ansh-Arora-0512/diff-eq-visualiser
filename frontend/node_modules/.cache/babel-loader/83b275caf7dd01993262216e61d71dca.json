{"ast":null,"code":"var _jsxFileName = \"/Users/kirillrybkov/Desktop/diff-eq-visualiser/frontend/src/components/EqContext.js\";\nimport React, { createContext, useContext, useRef, useState } from 'react';\nexport const EqContext = createContext();\nexport function useEq() {\n  return useContext(EqContext);\n}\nexport function EqProvider({\n  children\n}) {\n  const mathFieldRef = useRef(null);\n  const [eq, setEq] = useState(\"\");\n  const tokens = new Set([\"{}={}\", \"{}\\\\gt{}\", \"{}\\\\ge{}\", \"{}\\\\lt{}\", \"{}\\\\le{}\", \"{}+{}\", \"{}-{}\", \"{}\\\\cdot{}\", \"{}\\\\div{}\", \"{}^{}\", \"{}_{}\", \"{}\\\\to{}\", \"\\\\frac{}{}\", \"\\\\frac{d}{d{}}{}\", \"\\\\partial{}\", \"\\\\lim_{}{}\", \"\\\\sqrt{}\", \"\\\\sqrt[{}]{}\", \"\\\\log{}\", \"\\\\log_{}{}\", \"\\\\binom{}{}\", \"\\\\sum_{}^{}{}\", \"\\\\prod_{}^{}{}\", \"\\\\int_{}^{}{}\", \"\\\\oint_{}^{}{}\", \"\\\\left({}\\\\right)\", \"\\\\left[{}\\\\right]\", \"\\\\left|{}\\\\right|\", \"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\", \"\\\\left\\\\lceil{}\\\\right\\\\rceil\"]);\n  function splitBranches(tree, ...operators) {\n    const operator = operators[0];\n    let new_tree;\n    let tree_flag;\n    let len;\n    let prev;\n    let char;\n    let new_branch;\n    let branch;\n    for (let branch_index = tree.length - 1; branch >= 0; branch--) {\n      branch = tree[branch_index];\n      if (typeof branch === \"string\") {\n        new_tree = [];\n        tree_flag = false;\n        len = branch.length;\n        prev = len;\n        for (let i = len - 1; i >= 0; i--) {\n          char = branch[i];\n          if (operators.includes(char)) {\n            new_branch.push(char, [], branch.slice(i + 1, prev));\n            new_branch = new_branch[1];\n            prev = i;\n            tree_flag = true;\n          }\n        }\n        if (tree_flag) {\n          tree[branch_index] = new_tree;\n        }\n      } else {\n        tree[branch_index] = splitBranches(branch);\n      }\n    }\n    const expr = tree[0];\n    const operands = [];\n    let operand_index = tree.length - 1;\n    new_tree = [];\n    tree_flag = false;\n    len = expr.length;\n    prev = len;\n    for (let i = len - 1; i >= 0; i--) {\n      char = expr[i];\n      if (operators.includes(char) && (i > len - 5 || expr.slice(i + 1, i + 5) != \"{}{}\")) {\n        tree_flag = true;\n        new_tree.push(char, [], operands ? [expr.slice(i + 1, prev), ...operands] : expr.slice(i + 1, prev));\n        new_tree = new_tree[1];\n        prev = i;\n        operands = [];\n      } else if (char === \"{\") {\n        operands.unshift(tree[operand_index]);\n        operand_index--;\n      }\n    }\n    return tree_flag ? new_tree : tree;\n  }\n  function generateTree() {\n    const brace_stack = [];\n    const tree = [];\n    let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n    for (let i = 0; i < eq.length; i++) {\n      switch (eq[i]) {\n        case \"{\":\n          brace_stack[brace_stack.length - 1].push(i + 1);\n          brace_stack.push([i + 1]);\n        case \"}\":\n          expr = \"\";\n          brace_pairs = brace_stack.pop();\n          brace_pairs.push(i);\n          len = brace_pairs.length;\n          operands = len > 2;\n          for (let j = 0; j < len; j += 2) {\n            expr += eq.slice(brace_pairs[j], brace_pairs[j + 1]);\n          }\n          if (operands) {\n            tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n          } else {\n            if (!isNaN(expr)) {\n              expr = +expr;\n            }\n            tree.push(expr);\n          }\n          brace_stack[brace_stack.length - 1].push(i);\n      }\n    }\n    tree = splitBranches(tree, \"+\", \"-\");\n    tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n    tree = splitBranches(tree, \"^\");\n    return tree;\n  }\n  function writeLatex(latex, isCmd = false, lcount = 0) {\n    var _mathFieldRef$current;\n    const mathField = mathFieldRef === null || mathFieldRef === void 0 ? void 0 : (_mathFieldRef$current = mathFieldRef.current) === null || _mathFieldRef$current === void 0 ? void 0 : _mathFieldRef$current.mathField;\n    if (mathField) {\n      if (isCmd) {\n        mathField.cmd(latex);\n      } else {\n        mathField.typedText(latex);\n      }\n      mathField.keystoke(\"Left \".repeat(lcount));\n      setEq(mathField.latex());\n    }\n  }\n  return /*#__PURE__*/React.createElement(EqContext.Provider, {\n    value: {\n      mathFieldRef,\n      writeLatex,\n      eq,\n      setEq\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 5\n    }\n  }, children);\n}","map":{"version":3,"names":["React","createContext","useContext","useRef","useState","EqContext","useEq","EqProvider","children","mathFieldRef","eq","setEq","tokens","Set","splitBranches","tree","operators","operator","new_tree","tree_flag","len","prev","char","new_branch","branch","branch_index","length","i","includes","push","slice","expr","operands","operand_index","unshift","generateTree","brace_stack","brace_pairs","last_is_num","last_is_alpha","pop","j","splice","isNaN","writeLatex","latex","isCmd","lcount","_mathFieldRef$current","mathField","current","cmd","typedText","keystoke","repeat","createElement","Provider","value","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["/Users/kirillrybkov/Desktop/diff-eq-visualiser/frontend/src/components/EqContext.js"],"sourcesContent":["import React, { createContext, useContext, useRef, useState } from 'react';\n\nexport const EqContext = createContext();\n\nexport function useEq() {\n  return useContext(EqContext);\n}\n\nexport function EqProvider({ children }) {\n  const mathFieldRef = useRef(null);\n  const [eq, setEq] = useState(\"\");\n\n  const tokens = new Set([\n    \"{}={}\", \"{}\\\\gt{}\", \"{}\\\\ge{}\", \"{}\\\\lt{}\", \"{}\\\\le{}\",\n    \"{}+{}\", \"{}-{}\", \"{}\\\\cdot{}\", \"{}\\\\div{}\", \"{}^{}\", \"{}_{}\", \"{}\\\\to{}\",\n    \"\\\\frac{}{}\", \"\\\\frac{d}{d{}}{}\", \"\\\\partial{}\", \"\\\\lim_{}{}\",\n    \"\\\\sqrt{}\", \"\\\\sqrt[{}]{}\", \"\\\\log{}\", \"\\\\log_{}{}\", \"\\\\binom{}{}\",\n    \"\\\\sum_{}^{}{}\", \"\\\\prod_{}^{}{}\", \"\\\\int_{}^{}{}\", \"\\\\oint_{}^{}{}\",\n    \"\\\\left({}\\\\right)\", \"\\\\left[{}\\\\right]\", \"\\\\left|{}\\\\right|\",\n    \"\\\\left\\\\lfloor{}\\\\right\\\\rfloor\", \"\\\\left\\\\lceil{}\\\\right\\\\rceil\"\n  ]);\n\n  function splitBranches(tree, ...operators) {\n    const operator = operators[0];\n    let new_tree\n    let tree_flag\n    let len\n    let prev\n    let char\n    let new_branch\n    let branch\n\n    for (let branch_index = tree.length - 1; branch >= 0; branch--) {\n      branch = tree[branch_index];\n      if (typeof branch === \"string\") {\n        new_tree = []\n        tree_flag = false\n        len = branch.length\n        prev = len;\n        for (let i = len - 1; i >= 0; i--) {\n          char = branch[i];\n          if (operators.includes(char)) {\n            new_branch.push(char, [], branch.slice(i + 1, prev));\n            new_branch = new_branch[1];\n            prev = i;\n            tree_flag = true;\n          }\n        }\n        if (tree_flag) {\n          tree[branch_index] = new_tree;\n        }\n      } else {\n        tree[branch_index] = splitBranches(branch);\n      }\n    }\n\n    const expr = tree[0]\n    const operands = [];\n    let operand_index = tree.length - 1;\n    new_tree = []\n    tree_flag = false\n    len = expr.length\n    prev = len;\n    for (let i = len - 1; i >= 0; i--) {\n      char = expr[i];\n      if (operators.includes(char) && (i > len - 5 || expr.slice(i + 1, i + 5) != \"{}{}\")) {\n        tree_flag = true;\n        new_tree.push(char, [], (operands ? [expr.slice(i + 1, prev), ...operands] : expr.slice(i + 1, prev)));\n        new_tree = new_tree[1];\n        prev = i;\n        operands = [];\n      } else if (char === \"{\") {\n        operands.unshift(tree[operand_index]);\n        operand_index--;\n      }\n    }\n    return (tree_flag ? new_tree : tree)\n  }\n  \n  function generateTree() {\n    const brace_stack = []\n    const tree = []\n    let expr, brace_pairs, len, operands, last_is_num, last_is_alpha;\n\n    for (let i = 0; i < eq.length; i++) {\n      switch (eq[i]) {\n        case \"{\":\n          brace_stack[brace_stack.length - 1].push(i+1);\n          brace_stack.push([i + 1]);\n\n        case \"}\":\n          expr = \"\";\n          brace_pairs = brace_stack.pop();\n          brace_pairs.push(i);\n          len = brace_pairs.length;\n          operands = len > 2;\n          for (let j = 0; j < len; j+=2) {\n            expr += eq.slice(brace_pairs[j], brace_pairs[j+1]);\n          }\n\n          if (operands) {\n            tree.splice(-operands, operands, [expr, ...tree.slice(-operands)]);\n          } else {\n            if (!isNaN(expr)) {\n              expr = +expr;\n            }\n            tree.push(expr);\n          }\n          brace_stack[brace_stack.length - 1].push(i);\n      }\n    }\n    \n    tree = splitBranches(tree, \"+\", \"-\");\n    tree = splitBranches(tree, \"\\\\cdot\", \"\\\\div\");\n    tree = splitBranches(tree, \"^\");\n    return tree;\n  }\n\n  function writeLatex(latex, isCmd=false, lcount=0) {\n    const mathField = mathFieldRef?.current?.mathField; \n    if (mathField) {\n      if (isCmd) {\n        mathField.cmd(latex);\n      } else {\n        mathField.typedText(latex);\n      }\n      mathField.keystoke(\"Left \".repeat(lcount));\n      setEq(mathField.latex());\n    }\n  }\n\n  return (\n    <EqContext.Provider \n      value={{ \n        mathFieldRef,\n        writeLatex,\n        eq,\n        setEq\n      }}\n    >\n      {children}\n    </EqContext.Provider>\n  );\n}\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAE1E,OAAO,MAAMC,SAAS,GAAGJ,aAAa,CAAC,CAAC;AAExC,OAAO,SAASK,KAAKA,CAAA,EAAG;EACtB,OAAOJ,UAAU,CAACG,SAAS,CAAC;AAC9B;AAEA,OAAO,SAASE,UAAUA,CAAC;EAAEC;AAAS,CAAC,EAAE;EACvC,MAAMC,YAAY,GAAGN,MAAM,CAAC,IAAI,CAAC;EACjC,MAAM,CAACO,EAAE,EAAEC,KAAK,CAAC,GAAGP,QAAQ,CAAC,EAAE,CAAC;EAEhC,MAAMQ,MAAM,GAAG,IAAIC,GAAG,CAAC,CACrB,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EACvD,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,WAAW,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EACzE,YAAY,EAAE,kBAAkB,EAAE,aAAa,EAAE,YAAY,EAC7D,UAAU,EAAE,cAAc,EAAE,SAAS,EAAE,YAAY,EAAE,aAAa,EAClE,eAAe,EAAE,gBAAgB,EAAE,eAAe,EAAE,gBAAgB,EACpE,mBAAmB,EAAE,mBAAmB,EAAE,mBAAmB,EAC7D,iCAAiC,EAAE,+BAA+B,CACnE,CAAC;EAEF,SAASC,aAAaA,CAACC,IAAI,EAAE,GAAGC,SAAS,EAAE;IACzC,MAAMC,QAAQ,GAAGD,SAAS,CAAC,CAAC,CAAC;IAC7B,IAAIE,QAAQ;IACZ,IAAIC,SAAS;IACb,IAAIC,GAAG;IACP,IAAIC,IAAI;IACR,IAAIC,IAAI;IACR,IAAIC,UAAU;IACd,IAAIC,MAAM;IAEV,KAAK,IAAIC,YAAY,GAAGV,IAAI,CAACW,MAAM,GAAG,CAAC,EAAEF,MAAM,IAAI,CAAC,EAAEA,MAAM,EAAE,EAAE;MAC9DA,MAAM,GAAGT,IAAI,CAACU,YAAY,CAAC;MAC3B,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;QAC9BN,QAAQ,GAAG,EAAE;QACbC,SAAS,GAAG,KAAK;QACjBC,GAAG,GAAGI,MAAM,CAACE,MAAM;QACnBL,IAAI,GAAGD,GAAG;QACV,KAAK,IAAIO,CAAC,GAAGP,GAAG,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACjCL,IAAI,GAAGE,MAAM,CAACG,CAAC,CAAC;UAChB,IAAIX,SAAS,CAACY,QAAQ,CAACN,IAAI,CAAC,EAAE;YAC5BC,UAAU,CAACM,IAAI,CAACP,IAAI,EAAE,EAAE,EAAEE,MAAM,CAACM,KAAK,CAACH,CAAC,GAAG,CAAC,EAAEN,IAAI,CAAC,CAAC;YACpDE,UAAU,GAAGA,UAAU,CAAC,CAAC,CAAC;YAC1BF,IAAI,GAAGM,CAAC;YACRR,SAAS,GAAG,IAAI;UAClB;QACF;QACA,IAAIA,SAAS,EAAE;UACbJ,IAAI,CAACU,YAAY,CAAC,GAAGP,QAAQ;QAC/B;MACF,CAAC,MAAM;QACLH,IAAI,CAACU,YAAY,CAAC,GAAGX,aAAa,CAACU,MAAM,CAAC;MAC5C;IACF;IAEA,MAAMO,IAAI,GAAGhB,IAAI,CAAC,CAAC,CAAC;IACpB,MAAMiB,QAAQ,GAAG,EAAE;IACnB,IAAIC,aAAa,GAAGlB,IAAI,CAACW,MAAM,GAAG,CAAC;IACnCR,QAAQ,GAAG,EAAE;IACbC,SAAS,GAAG,KAAK;IACjBC,GAAG,GAAGW,IAAI,CAACL,MAAM;IACjBL,IAAI,GAAGD,GAAG;IACV,KAAK,IAAIO,CAAC,GAAGP,GAAG,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACjCL,IAAI,GAAGS,IAAI,CAACJ,CAAC,CAAC;MACd,IAAIX,SAAS,CAACY,QAAQ,CAACN,IAAI,CAAC,KAAKK,CAAC,GAAGP,GAAG,GAAG,CAAC,IAAIW,IAAI,CAACD,KAAK,CAACH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM,CAAC,EAAE;QACnFR,SAAS,GAAG,IAAI;QAChBD,QAAQ,CAACW,IAAI,CAACP,IAAI,EAAE,EAAE,EAAGU,QAAQ,GAAG,CAACD,IAAI,CAACD,KAAK,CAACH,CAAC,GAAG,CAAC,EAAEN,IAAI,CAAC,EAAE,GAAGW,QAAQ,CAAC,GAAGD,IAAI,CAACD,KAAK,CAACH,CAAC,GAAG,CAAC,EAAEN,IAAI,CAAE,CAAC;QACtGH,QAAQ,GAAGA,QAAQ,CAAC,CAAC,CAAC;QACtBG,IAAI,GAAGM,CAAC;QACRK,QAAQ,GAAG,EAAE;MACf,CAAC,MAAM,IAAIV,IAAI,KAAK,GAAG,EAAE;QACvBU,QAAQ,CAACE,OAAO,CAACnB,IAAI,CAACkB,aAAa,CAAC,CAAC;QACrCA,aAAa,EAAE;MACjB;IACF;IACA,OAAQd,SAAS,GAAGD,QAAQ,GAAGH,IAAI;EACrC;EAEA,SAASoB,YAAYA,CAAA,EAAG;IACtB,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMrB,IAAI,GAAG,EAAE;IACf,IAAIgB,IAAI,EAAEM,WAAW,EAAEjB,GAAG,EAAEY,QAAQ,EAAEM,WAAW,EAAEC,aAAa;IAEhE,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,EAAE,CAACgB,MAAM,EAAEC,CAAC,EAAE,EAAE;MAClC,QAAQjB,EAAE,CAACiB,CAAC,CAAC;QACX,KAAK,GAAG;UACNS,WAAW,CAACA,WAAW,CAACV,MAAM,GAAG,CAAC,CAAC,CAACG,IAAI,CAACF,CAAC,GAAC,CAAC,CAAC;UAC7CS,WAAW,CAACP,IAAI,CAAC,CAACF,CAAC,GAAG,CAAC,CAAC,CAAC;QAE3B,KAAK,GAAG;UACNI,IAAI,GAAG,EAAE;UACTM,WAAW,GAAGD,WAAW,CAACI,GAAG,CAAC,CAAC;UAC/BH,WAAW,CAACR,IAAI,CAACF,CAAC,CAAC;UACnBP,GAAG,GAAGiB,WAAW,CAACX,MAAM;UACxBM,QAAQ,GAAGZ,GAAG,GAAG,CAAC;UAClB,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,GAAG,EAAEqB,CAAC,IAAE,CAAC,EAAE;YAC7BV,IAAI,IAAIrB,EAAE,CAACoB,KAAK,CAACO,WAAW,CAACI,CAAC,CAAC,EAAEJ,WAAW,CAACI,CAAC,GAAC,CAAC,CAAC,CAAC;UACpD;UAEA,IAAIT,QAAQ,EAAE;YACZjB,IAAI,CAAC2B,MAAM,CAAC,CAACV,QAAQ,EAAEA,QAAQ,EAAE,CAACD,IAAI,EAAE,GAAGhB,IAAI,CAACe,KAAK,CAAC,CAACE,QAAQ,CAAC,CAAC,CAAC;UACpE,CAAC,MAAM;YACL,IAAI,CAACW,KAAK,CAACZ,IAAI,CAAC,EAAE;cAChBA,IAAI,GAAG,CAACA,IAAI;YACd;YACAhB,IAAI,CAACc,IAAI,CAACE,IAAI,CAAC;UACjB;UACAK,WAAW,CAACA,WAAW,CAACV,MAAM,GAAG,CAAC,CAAC,CAACG,IAAI,CAACF,CAAC,CAAC;MAC/C;IACF;IAEAZ,IAAI,GAAGD,aAAa,CAACC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC;IACpCA,IAAI,GAAGD,aAAa,CAACC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC;IAC7CA,IAAI,GAAGD,aAAa,CAACC,IAAI,EAAE,GAAG,CAAC;IAC/B,OAAOA,IAAI;EACb;EAEA,SAAS6B,UAAUA,CAACC,KAAK,EAAEC,KAAK,GAAC,KAAK,EAAEC,MAAM,GAAC,CAAC,EAAE;IAAA,IAAAC,qBAAA;IAChD,MAAMC,SAAS,GAAGxC,YAAY,aAAZA,YAAY,wBAAAuC,qBAAA,GAAZvC,YAAY,CAAEyC,OAAO,cAAAF,qBAAA,uBAArBA,qBAAA,CAAuBC,SAAS;IAClD,IAAIA,SAAS,EAAE;MACb,IAAIH,KAAK,EAAE;QACTG,SAAS,CAACE,GAAG,CAACN,KAAK,CAAC;MACtB,CAAC,MAAM;QACLI,SAAS,CAACG,SAAS,CAACP,KAAK,CAAC;MAC5B;MACAI,SAAS,CAACI,QAAQ,CAAC,OAAO,CAACC,MAAM,CAACP,MAAM,CAAC,CAAC;MAC1CpC,KAAK,CAACsC,SAAS,CAACJ,KAAK,CAAC,CAAC,CAAC;IAC1B;EACF;EAEA,oBACE7C,KAAA,CAAAuD,aAAA,CAAClD,SAAS,CAACmD,QAAQ;IACjBC,KAAK,EAAE;MACLhD,YAAY;MACZmC,UAAU;MACVlC,EAAE;MACFC;IACF,CAAE;IAAA+C,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAEDvD,QACiB,CAAC;AAEzB","ignoreList":[]},"metadata":{},"sourceType":"module"}